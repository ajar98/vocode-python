---
title: "Sentry SDK Integration"
description: "Integrate Sentry for error tracking and performance monitoring"
---

## What is Sentry?

[Sentry](https://sentry.io/) is an open-source error tracking tool that helps developers monitor and fix crashes in real-time. It provides insights into the health of your applications by capturing and reporting errors, exceptions, and performance issues.

## Why integrate Sentry?

Integrating Sentry into your application allows you to:

- Automatically capture and report errors and exceptions.
- Monitor the performance of your application.
- Gain insights into the user experience and identify bottlenecks.
- Improve the overall reliability and stability of your application.

## Configuring Sentry SDK

To integrate Sentry into your application, you need to initialize the Sentry SDK at the earliest instantiation point in your code. This ensures that Sentry starts capturing errors and performance data as soon as possible.

Here's how you can configure the Sentry SDK:

```python
import os
import sentry_sdk
from sentry_sdk.integrations.asyncio import AsyncioIntegration
from sentry_sdk.integrations.logging import LoguruIntegration

sentry_sdk.init(
    dsn=os.getenv("SENTRY_DSN"),
    environment=os.getenv("ENVIRONMENT"),
    # Sample rate for transactions (performance).
    traces_sample_rate=float(os.getenv("SENTRY_TRACES_SAMPLE_RATE", 1.0)),
    profiles_sample_rate=float(os.getenv("SENTRY_TRACES_SAMPLE_RATE", 1.0)),
    # Sample rate for exceptions / crashes.
    sample_rate=float(os.getenv("SENTRY_SAMPLE_RATE", 1.0)),
    max_request_body_size="always",
    integrations=[
        AsyncioIntegration(),
        LoguruIntegration(),
    ],
)
```

### Explanation of Configuration Settings

- `dsn`: The Data Source Name (DSN) is a unique identifier for your Sentry project. It tells the SDK where to send the captured data.
- `environment`: The environment in which your application is running (e.g., production, staging, development).
- `traces_sample_rate`: The sample rate for capturing performance data (transactions). A value of `1.0` means 100% of transactions will be captured.
- `profiles_sample_rate`: The sample rate for capturing profiling data. Similar to `traces_sample_rate`.
- `sample_rate`: The sample rate for capturing errors and exceptions. A value of `1.0` means 100% of errors will be captured.
- `max_request_body_size`: Configures the maximum size of request bodies to capture. Setting it to `"always"` ensures all request bodies are captured.
- `integrations`: A list of integrations to use with Sentry. In this case, we're using `AsyncioIntegration` for asyncio support and `LoguruIntegration` for Loguru logging support.

## Custom Sentry Spans

In addition to automatic error and performance monitoring, you can manually create and manage spans to gain deeper insights into specific parts of your application. The `CustomSentrySpans` class defines several custom spans that you can use to measure specific events and durations within your application. Here's a more human-readable explanation of each span and what it captures:

### Span Descriptions

1. **Connected to First Send** _(`CONNECTED_TO_FIRST_SEND`)_: Measures the time from when a connection is established to when the first data is sent. This can help identify delays in the initial data transmission.

2. **Endpointing Latency** _(`ENDPOINTING_LATENCY`)_: Captures the latency involved in endpointing, which is the process of determining the end of a spoken phrase or sentence. This is crucial for applications involving speech recognition.

3. **First Send to First Receive** _(`FIRST_SEND_TO_FIRST_RECEIVE`)_: Measures the time from when the first data is sent to when the first response is received. This span helps in understanding the round-trip time for the initial communication.

4. **Language Model Time to First Token** _(`LANGUAGE_MODEL_TIME_TO_FIRST_TOKEN`)_: Tracks the time taken by the language model to generate the first token (word or character) in its response. This is useful for evaluating the performance of language models like GPT-4o.

5. **Latency of Conversation** _(`LATENCY_OF_CONVERSATION`)_: Measures the overall latency of a conversation, from start to finish. This span provides insights into the responsiveness of the entire conversational flow.

6. **Latency of Transcription Start** _(`LATENCY_OF_TRANSCRIPTION_START`)_: Captures the time taken to start the transcription process after receiving audio input. This is important for applications that convert speech to text.

7. **LLM First Sentence Total** _(`LLM_FIRST_SENTENCE_TOTAL`)_: Measures the total time taken by the language model to generate the first complete sentence. This span helps in assessing the initial response time of the language model.

8. **Start to Connection** _(`START_TO_CONNECTION`)_: Tracks the time from the start of an operation to the establishment of a connection. This can help identify delays in the connection setup phase.

9. **Synthesis Generate First Chunk** _(`SYNTHESIS_GENERATE_FIRST_CHUNK`)_: Measures the time taken to generate the first chunk of synthesized speech. This is crucial for applications that convert text to speech.

10. **Synthesis Time to First Token** _(`SYNTHESIS_TIME_TO_FIRST_TOKEN`)_: Captures the time taken to generate the first token (word or character) in the synthesized speech. This span helps in evaluating the performance of speech synthesis models.

11. **Time to First Token** _(`TIME_TO_FIRST_TOKEN`)_: Measures the overall time taken to generate the first token in any process, whether it's language modeling or speech synthesis. This span provides a general metric for initial response time.

12. **Synthesizer Synthesis Total** _(`SYNTHESIZER_SYNTHESIS_TOTAL`)_: Tracks the total time taken for the entire speech synthesis process. This span helps in understanding the overall performance of the synthesizer.

13. **Synthesizer Time to First Token** _(`SYNTHESIZER_TIME_TO_FIRST_TOKEN`)_: Measures the time taken by the synthesizer to generate the first token in the synthesized speech. This is useful for evaluating the initial response time of the synthesizer.

14. **Synthesizer Create Speech** _(`SYNTHESIZER_CREATE_SPEECH`)_: Captures the time taken to create the entire speech output. This span provides insights into the performance of the speech creation process.

#### Note on Synthesizer Spans

The following spans will have the actual synthesizer's name prepended to them. For example, if the synthesizer is `ElevenLabsSynthesizer`, the span `SYNTHESIZER_SYNTHESIS_TOTAL` will be recorded as `ElevenLabsSynthesizer.synthesis_total`:

- **Synthesis Total** _(`SYNTHESIZER_SYNTHESIS_TOTAL`)_
- **Time to First Token** _(`SYNTHESIZER_TIME_TO_FIRST_TOKEN`)_
- **Create Speech** _(`SYNTHESIZER_CREATE_SPEECH`)_

This naming convention helps in identifying and differentiating spans for various synthesizers in your application.

## Wrap Up

Integrating Sentry into your application provides valuable insights into errors, exceptions, and performance issues. By configuring the Sentry SDK and using custom spans, you can monitor the health of your application and improve its reliability and stability.

For more information on Sentry and its features, refer to the [official documentation](https://docs.sentry.io/).
